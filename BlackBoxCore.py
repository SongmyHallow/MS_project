'''
MS project algorithm
Muyi Song (muyis)
Latest update: 8/15/2019

command line syntax: python BlackBox.py (name of model file) (number of iterations)
                                            sys.argv[1]             sys.argv[2]
sampling methods:
1. Hammersley sequence
2. Ver der Corput sequence
3. Halton sequence
4. Latin Random
5. Sobol sequence

search algorithm:
1. Coordinate search (shuffle the order of variables every iteration)
================================================================================
'''
import os
import sys
from pyomo.environ import *
from pyomo.opt import SolverFactory
"""
================================================================================
support functions
================================================================================
"""

'''
@input: name of c file, sequence of values
@output: None. 'input.in' will be generated
'''
def writeInput(filename,input_values):
    infile = open(filename, 'w')
    for val in input_values:
        infile.write(str(val)+'\n')
    infile.close()

def readOutput(filename):
    readfile = open(filename, 'r')
    line = readfile.readline()
    if(line.strip() == "1.#INF00000000000"):
        return "INF"
    else:
        output_value = float(line.strip())
        return output_value
    
def genBlackBoxValue(filename,input_values):
    input_filename = "input.in"
    output_filename = "output.out"
    
    writeInput(input_filename,input_values)
    os.system('.\\'+filename)
    output_value = readOutput(output_filename)
    return output_value

def genBlackBoxValuesSeq(filename,point,sequence,index):
    input_filename = "input.in"
    output_filename = "output.out"
    output_values = []
    for val in sequence:
        input_copy = point[:]
        input_copy[index] = val
        writeInput(input_filename,input_copy)
        os.system('.\\'+filename)
        output_values.append(readOutput(output_filename))
    return output_values
    
def boundary_dic(labels,lb,ub):
    lowerBound = {labels[0]:lb}
    upperBound = {labels[0]:ub}
    return lowerBound,upperBound
'''
Regression, use alamopy package to get the numerical expression
:param list input_values: values of variables
:param list output_values: values generated by black box models
:paran real lowerBound: lower boundary of specific variable
:param real upperBound: upper boundary of specific variable
:ruturn: labels of variables and expression of the function
'''
def callAlamopy(input_values,output_values,lowBound,upBound):
    import alamopy
    # print(input_values)
    alamo_result = alamopy.alamo(xdata=input_values,zdata=output_values,xmin=lowBound,xmax=upBound,monomialpower=(1,2))
#     print("===============================================================")
#     print("ALAMO results")
#     print("===============================================================")
#     print("#Model expression: ",alamo_result['model'])
#     print("#Rhe sum of squared residuals: ",alamo_result['ssr'])
#     print("#R squared: ",alamo_result['R2'])
#     print("#Root Mean Square Error: ",alamo_result['rmse'])
#     print("---------------------------------------------------------------")
    labels = alamo_result['xlabels']
    expr = alamo_result['f(model)']
    return labels,expr

def saveTemp(dic,Xdata,ydata):
    for i,j in zip(Xdata,ydata):
        if i not in dic.keys():
            dic[i] = j
    return

def retrieveTemp(dic,lb,ub,Xdata,ydata):
    for key in dic.keys():
        if key>lb and key<ub and key not in Xdata:
            Xdata.append(key)
            ydata.append(dic[key])
    return
  
"""
================================================================================
definition of the core class
================================================================================
"""
class blackBox(object):
    def __init__(self,name=None,cycles=0,radius=None,samples=None,
                 numOfVar=0,
                 lowBound=[],upBound=[],
                 iniStart=[],backUpStart=[],actualStart=[],
                 minimalCoordinate=[],minimalValue=[],allValue=[],
                 totalCalls=0,calls=[],allCalls=[],
                 error=0,endCycle=0):
        self.name = name
        self.cycles = cycles
        self.radius = radius
        self.samples = samples
        self.numOfVar = numOfVar
        self.lowBound = lowBound
        self.upBound = upBound
        self.iniStart = iniStart
        self.backUpStart = backUpStart
        self.actualStart = actualStart
        self.totalCalls = totalCalls
        self.calls = calls
        self.allCalls = allCalls

        self.minimalCoordinate = minimalCoordinate
        self.minimalValue = minimalValue  
        self.allValue = allValue
        self.error = error
        self.endCycle = endCycle
        self.trapIndicater = 0

    def clear(self):
        self.radius = 0
        self.samples = 0
        self.lowBound = []
        self.upBound = []
        self.calls = []
        self.totalCalls = 0
        self.allCalls = []
 
    def showParameter(self):
        print("Name:",self.name)
        print("Total number of cycles:",self.cycles)
        print("Search radius:",self.radius)
        print("Number of variables:",self.numOfVar)
        print("lowBound:",self.lowBound)
        print("upBound:",self.upBound)
        print("Initial starting point from data file:",self.iniStart)
        print("Back up starting points:",self.backUpStart)
        print("Actual starting point is:",self.actualStart)

    def getCalls(self):
        print("Total call:",self.totalCalls)
        print("Calls list:",self.calls)

    def getResult(self):
        print("All number of calls:",self.allCalls)
        print("All local optimal:",self.allValue)

        print("Optimal values:",self.minimalValue)
        print("Optimal points:",self.minimalCoordinate)
        
    '''
    Compile .c file
    :param string filename: name of c file (with out extension)
    ''' 
    def compileCode(self):
        os.system('gcc source_princetonlibgloballib/'+self.name+'.c -lm -o '+self.name)
        after_name = self.name+".exe"
        print("Blackbox Model Name: ",self.name)
        if(os.path.exists(after_name)):
            print("Compilation finished")
        else:
            print("Compilation failed")
    
    '''
    Read boundaries, starting points and number of variables
    :param string filename: name of c file (with out extension)
    '''
    def readDataFile(self):
        infile = open("problemdata/"+self.name+".problem.data",'r')
        lines = infile.readlines()
        # The first line
        for num in lines[0].split():
            self.numOfVar = int(num.strip())
        # The second line
        for i in lines[1].split():
            self.lowBound.append(float(i.strip()))
        # The third line
        for j in lines[2].split():
            self.upBound.append(float(j.strip()))
        # The fourth line
        for k in lines[3].split():
            self.iniStart.append(float(k.strip()))
        infile.close()
    '''
    Read reference solution of coordinate
    '''
    def readReferenceSol(self):
        infile = open("all/"+self.name+".sol",'r')
        lines = infile.readlines()
        coordinate = []
        for line in lines:
            for sol in line.split():
                coordinate.append(float(sol))
        infile.close()
        return coordinate

    def readRefOptimal(self):
        import xlrd
        infile = xlrd.open_workbook('ModelList.xlsx')
        table = infile.sheet_by_name('models')

        sol = 0
        for rownum in range(0,table.nrows):
            row = table.row_values(rownum)
            if row[1] == self.name:
                sol = row[6]
        return float(sol)

    '''
    Generate starting points that are ready to be chose
    '''
    def genBackupStart(self):
        import numpy as np    
        # TODO: Finally I want to generate 10 backup starting points, which can be modifed later
        for i in range(len(self.lowBound)):
            arr = np.linspace(self.lowBound[i],self.upBound[0],17)
            self.backUpStart.append(arr)
        self.backUpStart = np.transpose(self.backUpStart)[1:-1]
    
    '''
    Choose a starting point from backup and check if it is valid,
    otherwise remove that point from list and choose another one
    '''
    def genActualStart(self,method):
        import random
        if(method=="random"):
            self.actualStart = random.choice(self.backUpStart)
            output = genBlackBoxValue(self.name,self.actualStart)
            while(output == "INF"):
                self.backUpStart.remove(self.actualStart)
                self.actualStart = random.choice(self.backUpStart)
                output = genBlackBoxValue(self.name,self.actualStart)
        elif(method=="origin"):
            self.actualStart = self.iniStart

    '''
    Generate the boundary of specific variable at current iteration
    '''
    def genVariableBound(self,index):
        import random
        # Newer version
        if(self.actualStart[index]-self.radius[index]<self.lowBound[index]):
            lb = self.lowBound[index]
        else:
            lb = self.actualStart[index]-self.radius[index]
        
        if(self.actualStart[index]+self.radius[index]>self.upBound[index]):
            ub = self.upBound[index]
        else:
            ub = self.actualStart[index]+self.radius[index]
        # self.tempLB = lb
        # self.tempUB = ub
        # offset = random.uniform(lb,ub)
        return lb,ub

    def genVariableBoundOld(self,index):
        import random
        # Previous version
        if(self.actualStart[index]-self.radius<self.lowBound[index]):
            lb = self.lowBound[index]
        else:
            lb = self.actualStart[index]-self.radius
        
        if(self.actualStart[index]+self.radius>self.upBound[index]):
            ub = self.upBound[index]
        else:
            ub = self.actualStart[index]+self.radius
        return lb,ub
    
    '''
    Generate sampling points
    1. The Halton Quasi Monte Carlo (QMC) Sequence
    2. The Hammersley Quasi Monte Carlo (QMC) Sequence
    3. The van der Corput Quasi Monte Carlo (QMC) sequence
    4. Latin Random Squares in M dimensions
    5. Adaptive sampling from package 'adaptive'
    '''
    def genSamplePoints(self,method,num,lowBound,upBound):
        from Sampling import halton_sequence,hammersley_sequence,van_der_corput,latin_random_sequence,sobol_sequence
        if(method=="halton"):
            Xdata,_ = halton_sequence(lowBound,upBound,num)
        elif(method=="hammersley"):
            Xdata,_ = hammersley_sequence(lowBound,upBound,num)
        elif(method=="vander"):
            Xdata,_=van_der_corput(lowBound,upBound,num,2)
        elif(method=="latin"):
            Xdata,_ = latin_random_sequence(lowBound,upBound,num,1,1)
        elif(method=="sobol"):
            Xdata = sobol_sequence(lowBound,upBound,1,num)
        self.totalCalls+=num
        return Xdata

    '''
    Optimization, call baron by Pyomo to get optimal solution
    :param labels: labels of variables generated by alamopy
    :param expr: numerical expression generated by alamopy
    :param lowerBound
    :Param upperBound
    :param list startPoint: list of coordinate of the point
    :param integer index: index of the specific variable
    '''
    def callBaron(self,labels,expr,lowBound,upBound,index):
        model = ConcreteModel(name='blackbox')
        lBound_dic,uBound_dic = boundary_dic(labels,lowBound,upBound)
        def fb(model,i):
            return (lBound_dic[i],uBound_dic[i])
        model.A = Set(initialize=labels)
        model.x = Var(model.A,within=Reals,bounds=fb)
        
        def objrule(model):
            var_lst = []
            for var_name in model.x:
                var_lst.append(model.x[var_name])
            return expr(var_lst)
        model.obj = Objective(rule=objrule,sense=minimize)
        opt = SolverFactory('baron')
        solution = opt.solve(model)
        # solution.write()
        # model.pprint()
        # model.display()
        tempPoint = self.actualStart[:]
        try:
            tempPoint[index] = value(model.x[labels[0]])
            # print(value(model.x[labels[index]]))
        except:
            pass
        tempMinimal = value(model.obj)
        return tempPoint,tempMinimal

    '''
    Update the flag indicating the accuracy of surrogate model
    '''
    def updateFlag(self,tempPoint,tempMinimal,indexOfVar):
        import numpy as np
        boxVal = genBlackBoxValue(self.name,tempPoint)
        # print("Box value:",boxVal)
        # print("Temp minimal value:",tempMinimal)
        
        if(boxVal == 0):
            boxVal += 1e-5
        ratio = tempMinimal / boxVal
        print(tempMinimal,boxVal)
        if((ratio > 0.5 and ratio < 1.75) or (np.abs(tempMinimal-boxVal)<0.01)):
            self.actualStart = tempPoint
            if(len(self.minimalValue)<1 or boxVal<self.minimalValue[-1]):
                # self.actualStart = tempPoint
                self.minimalValue.append(boxVal)
                self.minimalCoordinate.append(tempPoint)
                self.calls.append(self.totalCalls)
            self.radius[indexOfVar] *= 3
            print("Raidus is increased to: ",self.radius[indexOfVar])
            return True,boxVal
        else:
            self.radius[indexOfVar] *= 0.8
            print("Raidus is decreased to: ",self.radius[indexOfVar])
            return False,boxVal
    
    def checkEnd(self):
        import numpy as np
        def checkVar(self):
            if(len(self.minimalValue)>1 and self.minimalValue[-2]-self.minimalValue[-1]<1e-4):
                return True
            else:
                return False
            # if len(self.minimalValue)<self.numOfVar:
            #     return False
            # else:
            #     values = self.minimalValue[len(self.minimalValue)-self.numOfVar:]
            #     var = np.var(values)
            #     if var < 0.1:
            #         return True
            #     else:
            #         return False

        # if(len(self.minimalValue)>1 and self.minimalValue[-2]-self.minimalValue[-1]<1e-2):
        #     return True
        if(len(self.minimalValue)>1 and checkVar(self)):
            return True
        else:
            return False

    '''
    make a plot, optimal values vs calls of model
    :param list values
    :param list calls
    :param string name: name of model
    '''
    def makePlot(self,titlename):
        import matplotlib.pyplot as plt
        plt.plot(self.allCalls, self.allValue, '-o')
        plt.xlabel("Function Evaluations")
        plt.ylabel("Evaluation Values")
        # for x, y in zip(self.allCalls, self.allValue):
        #     plt.text(x, y+0.3, '%.5f'%y, ha='center', va='bottom', fontsize=10.5)
        plt.title(titlename)
        plt.grid()
        plt.savefig("plots\\"+self.name+".png")
        print("Plot of model "+ self.name +" is saved")

    '''
    Write data into csv file
    '''
    def makeCsv(self,time):
        from pandas import DataFrame
        import csv
        csvfile = open('experimentDataNew.csv','a+',newline='')
        fieldsnames = ['model_name','time','cycle','values','error','calls','point']
        # writer = csv.writer(csvfile,delimiter=',', quotechar='"', quoting=csv.QUOTE_MINIMAL)
        writer = csv.DictWriter(csvfile,fieldnames=fieldsnames)
        # values = list_int2str(values)
        # calls = list_int2str(calls)
        # writer.writerow([name,calls[-1]]+values)
        if(len(self.minimalValue)>0):
            writer.writerow({
                'model_name':self.name,
                'time':time,
                'cycle':self.endCycle,
                'values':self.minimalValue[-1],
                'error':self.error,
                'calls':self.calls[-1],
                'point':self.minimalCoordinate[-1]
            })
        else:
            writer.writerow({
                'model_name':self.name,
                'time':time,
                'cycle':self.cycles,
                'values':None,
                'calls': self.totalCalls
            })
        csvfile.close()
    
    '''
    Algorithms
    '''
    '''
    1. Coordinate search
    :param integer cycles: execution loops
    :param list startPoint: 
    '''
    def coordinateSearch(self):
        import random
        import numpy as np
        # the number of sampling
        ini_sample = 8
        self.samples = [ini_sample for i in range(self.numOfVar)]
        ini_radius = 1
        self.radius = [ini_radius for i in range(self.numOfVar)]
        print(self.samples, self.radius)
        for cycle in range(self.cycles):
            print("The No.",cycle+1,"Cycle")
            # shuffle the order of dimension
            shuffleOrder = list(range(self.numOfVar))
            # random.shuffle(shuffleOrder)

            for indexOfVar in shuffleOrder:
                print("The No.",indexOfVar+1,"Variable")
                # flag of the quality of solution
                flag = False

                tempDict = {}

                # if the solution is not valid, then repeat
                while(flag==False):
                    # left bound and right bound
                    lb,ub = self.genVariableBound(indexOfVar)   
                    # sampling between lb and rb
                    Xdata = self.genSamplePoints("vander",self.samples[indexOfVar],lb,ub)
                    # get black box values of xdata
                    ydata = genBlackBoxValuesSeq(self.name,self.actualStart,Xdata,indexOfVar)

                    retrieveTemp(tempDict,lb,ub,Xdata,ydata)
                    saveTemp(tempDict,Xdata,ydata)
                    
                    # surrogate model
                    labels,expr = callAlamopy(Xdata,ydata,lb,ub)
                    tempPoint,tempMinimal = self.callBaron(labels,expr,lb,ub,indexOfVar)
                    flag,boxVal = self.updateFlag(tempPoint,tempMinimal,indexOfVar)
                    print("Flag",flag)

                    if(flag==False):
                        self.samples[indexOfVar] +=8
                    else:
                        # make sure that the number of samples will not be too small
                        if self.samples[indexOfVar] > 6:
                            self.samples[indexOfVar] = int(self.samples[indexOfVar]*0.5)
                        else:
                            self.samples[indexOfVar] = 3
                        self.allCalls.append(self.totalCalls)
                        self.allValue.append(boxVal)
                    if(self.checkEnd()==True or self.totalCalls > 5000):
                        if self.checkEnd==True:
                            print("Exit normally")
                        elif self.totalCalls > 6000:
                            print("Exceed calls limit")
                        ref_coordiante = self.readReferenceSol()
                        ref_optimal = self.readRefOptimal()
                        self.error = np.abs(ref_optimal-self.allValue[-1])/self.allValue[-1]
                        self.endCycle = cycle
                        return

    def coordinateSearchBeta(self):
        # Initialization
        ini_sample = 8
        self.samples = [ini_sample for i in range(self.numOfVar)]
        ini_radius = 1
        self.radius = [ini_radius for i in range(self.numOfVar)]

        for cycle in range(self.cycles):
            print("The No.",cycle+1,"Cycle")
            for indexOfVar in range(self.numOfVar):
                print("The No.",indexOfVar+1,"Variable")

                lb,ub = self.genVariableBound(indexOfVar)
                Xdata = self.genSamplePoints("vander",self.samples[indexOfVar],lb,ub)
                ydata = genBlackBoxValuesSeq(self.name, self.actualStart, Xdata, indexOfVar)

                labels, expr = callAlamopy(Xdata, ydata, lb, ub)
                tempPoint, tempMinimal = self.callBaron(labels,expr, lb, ub, indexOfVar)
                flag, boxVal = self.updateFlag(tempPoint,tempMinimal,indexOfVar)
                
                print("Flag: ", flag)
                if(flag == False):
                    self.samples[indexOfVar] += 8
                else:
                    self.samples[indexOfVar] = int(self.samples[indexOfVar]/2)
                    # Store all of the output and coordinates for future inspection
                    self.allCalls.append(self.totalCalls)
                    self.allValue.append(boxVal)
            if(self.checkEnd() == True):
                return

    def coordinateSearchOld(self,method):
        import random
        import numpy as np
        from Sampling import halton_sequence,hammersley_sequence,van_der_corput,latin_random_sequence,sobol_sequence
        import sobol_seq
                    
        self.radius = 1
        self.samples = 16
        for cycle in range(self.cycles):
            print("The No.",cycle+1,"cycle")
            shuffle = list(range(len(self.actualStart)))
            random.shuffle(shuffle)
            for indexOfVar in shuffle:
                print("The No.",indexOfVar+1,"Variable")
                # Generate boundaries of variables
                lb = 0
                ub = 0
                if(self.actualStart[indexOfVar]-self.radius<self.lowBound[indexOfVar]):
                    lb = self.lowBound[indexOfVar]
                else:
                    lb = self.actualStart[indexOfVar]-self.radius
                
                if(self.actualStart[indexOfVar]+self.radius>self.upBound[indexOfVar]):
                    ub = self.upBound[indexOfVar]
                else:
                    ub = self.actualStart[indexOfVar]+self.radius
                Xdata,_=van_der_corput(lb,ub,self.samples,2)

                if(method=="halton"):
                    Xdata,_ = halton_sequence(lb,ub,self.samples)
                elif(method=="hammersley"):
                    Xdata,_ = hammersley_sequence(lb,ub,self.samples)
                elif(method=="vander"):
                    Xdata,_=van_der_corput(lb,ub,self.samples,2)
                elif(method=="latin"):
                    Xdata,_ = latin_random_sequence(lb,ub,self.samples,1,1)
                elif(method=="sobol"):
                    Xdata = sobol_sequence(lb,ub,1,self.samples)

                self.totalCalls+=self.samples
                ydata = genBlackBoxValuesSeq(self.name, self.actualStart, Xdata, indexOfVar)                
                # regression simulation
                labels, expr = callAlamopy(Xdata, ydata, lb, ub)
                tempPoint, tempMinimal = self.callBaron(labels,expr, lb, ub, indexOfVar)
                boxVal = genBlackBoxValue(self.name,tempPoint)
                # print("Box value:",boxVal)
                # print("Temp minimal value:",tempMinimal)
                if(boxVal == 0):
                    boxVal += 1e-5
                ratio = tempMinimal / boxVal
                print(tempMinimal,boxVal)

                flag = False
                if((ratio > 0.5 and ratio < 1.5) or (np.abs(tempMinimal-boxVal)<0.001)):
                    self.actualStart = tempPoint
                    if(len(self.minimalValue)<1 or boxVal<self.minimalValue[-1]):
                        self.minimalValue.append(boxVal)
                        self.minimalCoordinate.append(tempPoint)
                        self.calls.append(self.totalCalls)
                        print("New optimal value is found: ",boxVal," at:",tempPoint)
                    self.radius*= 3
                    print("Raidus is increased to: ",self.radius)
                    
                    flag = True
                else:
                    self.radius*= 0.8
                    print("Raidus is decreased to: ",self.radius)
                
                if(flag==False):
                    self.samples+=8
                else:
                    # make sure that the number of samples will not be too small
                    if self.samples > 6:
                        self.samples = int(self.samples*0.5)
                    else:
                        self.samples = 3
                    self.allCalls.append(self.totalCalls)
                    self.allValue.append(boxVal)
                
                endFlag = False
                if(len(self.minimalValue)>1 and self.minimalValue[-2]-self.minimalValue[-1]<1e-5):
                    endFlag = True
                # elif(len(self.minimalValue)>1 and np.abs(boxVal-self.minimalValue[-1]<1e-5)):
                #     self.trapIndicater += 1
                #     if self.trapIndicater > 20:
                #         endFlag = True
                else:
                    endFlag = False

                if(endFlag ==True or self.totalCalls > 5000):
                    if endFlag==True:
                        print("Exit normally:",self.calls[-1])
                    elif self.totalCalls > 5000:
                        print("Exceed calls limit:",self.calls[-1])
                    ref_coordiante = self.readReferenceSol()
                    ref_optimal = self.readRefOptimal()
                    self.error = np.abs(ref_optimal-self.allValue[-1])/self.allValue[-1]
                    self.endCycle = cycle
                    return

def HYSYSsimulation(cycles):
    import os
    import win32com.client as win32
    import numpy as np
    import time
    import random
    
    def hy_distinguish(hysolver):
        i=4
        P=np.linspace(0,0,num=1001)
        k=0
        timeover=0
        while k<2:
            i+=1
            solveboolean = 1-hysolver.issolving
            P[i] = solveboolean
            k = P[i-2] + P[i-1] + P[i]
            time.sleep(1)
            if P[1000]==1:
                timeover=1
                break
        return timeover	
    
    def hy_Object(hyCase, hysolver, variable):
        error=0
        error_type = np.array([0,0,0])
        butane = 100 - (variable[4] + variable[5] + variable[6] + variable[7])
        if variable[0]<=variable[1] and variable[1]<=variable[2] and variable[2]<=variable[3] and variable[4] >= 0:
            hyCase.Flowsheet.operations.Item('optimization').Cell('C2').cellvalue = variable[0]*100   #LP multiply 100 for making unit as bar
            hyCase.Flowsheet.operations.Item('optimization').Cell('C3').cellvalue = variable[1]*100   #MP1
            hyCase.Flowsheet.operations.Item('optimization').Cell('C4').cellvalue = variable[2]*100   #MP2
            hyCase.Flowsheet.operations.Item('optimization').Cell('C5').cellvalue = variable[3]*100   #HP
            hyCase.Flowsheet.operations.Item('optimization').Cell('C6').cellvalue = variable[4]   	  #Nitrogen
            hyCase.Flowsheet.operations.Item('optimization').Cell('C7').cellvalue = variable[5]       #Methane
            hyCase.Flowsheet.operations.Item('optimization').Cell('C8').cellvalue = variable[6]       #Ethane
            hyCase.Flowsheet.operations.Item('optimization').Cell('C9').cellvalue = variable[7]       #propane
            hyCase.Flowsheet.operations.Item('optimization').Cell('C10').cellvalue = butane    
            timeover=hy_distinguish(hysolver)
            # --there are infeasible signs?
            try:
                V1=hyCase.Flowsheet.operations.Item('optimization').Cell('I2').cellvalue
                V2=hyCase.Flowsheet.operations.Item('optimization').Cell('I3').cellvalue
                V3=hyCase.Flowsheet.operations.Item('optimization').Cell('I4').cellvalue
                V4=hyCase.Flowsheet.operations.Item('optimization').Cell('I5').cellvalue
                V5=hyCase.Flowsheet.operations.Item('optimization').Cell('I6').cellvalue
            except:
                hyCase.Flowsheet.operations.Item('optimization').Cell('C11').cellvalue = 3
                timeover=hy_distinguish(hysolver)
                error_type[1]=1
                if np.dot(error_type,error_type) !=0:
                    error=1
                    OBJ = np.random.random_sample()*10**30
                    return OBJ
                else:
                    pass
            
            if abs(V4-V5)>0.1:
                error_type[1]=1
                error =1
                OBJ = np.random.random_sample()*10**30
                return OBJ

            MTD_HX1 = hyCase.Flowsheet.operations.Item('optimization').Cell('C14').cellvalue
            MTD_HX2 = hyCase.Flowsheet.operations.Item('optimization').Cell('C16').cellvalue

            if MTD_HX1 <=2.85 or MTD_HX2<=2.85:
                hyCase.Flowsheet.operations.Item('optimization').Cell('C11').cellvalue = 3
                timeover=hy_distinguish(hysolver)
                if MTD_HX1 <=2.85 or MTD_HX2<=2.85:
                    error_type[0]=1
                    if np.dot(error_type,error_type) !=0:
                        error=1
                        OBJ = np.random.random_sample()*10**30
                        return OBJ
            
            VF1 = hyCase.Flowsheet.operations.Item('optimization').Cell('I8').cellvalue
            VF2 = hyCase.Flowsheet.operations.Item('optimization').Cell('I9').cellvalue
            VF3 = hyCase.Flowsheet.operations.Item('optimization').Cell('I10').cellvalue
            VF4 = hyCase.Flowsheet.operations.Item('optimization').Cell('I11').cellvalue
            VF5 = hyCase.Flowsheet.operations.Item('optimization').Cell('I12').cellvalue

            if VF1!=1 or VF2!=1 or VF3!=1 or VF4!=1 or VF5 !=1:
                error_type[2]=1
                if np.dot(error_type,error_type) !=0:
                    error =1
                    OBJ = np.random.random_sample()*10**30
                    return OBJ

            # -- Transfer output variables (HYSYS --> python)
            OBJ  = hyCase.Flowsheet.operations.Item('optimization').Cell('G10').cellvalue # E Total Energy Consumption / LNG Production(Ton per day)
            return OBJ
        else:
            error=1
            OBJ = np.random.random_sample()*10**30
            return OBJ

    def genHYSYSValuesSeq(point,sequence,index,hyCase,hysolver):
        ydata = []
        for val in sequence:
            input_copy = point[:]
            input_copy[index] = val
            f_x0 = hy_Object(hyCase, hysolver, input_copy)
            ydata.append(f_x0)
        return ydata

    def updateHYSYSflag(box,tempPoint,tempMinimal,indexOfVar,hyCase,hysolver):
        import numpy as np
        boxVal = hy_Object(hyCase, hysolver, tempPoint)
        # print("Box value:",boxVal)
        # print("Temp minimal value:",tempMinimal)
        if(boxVal == 0):
            boxVal += 1e-5
        ratio = tempMinimal / boxVal
        print(tempMinimal,boxVal)

        if(ratio > 0.5 and ratio < 1.5 or (np.abs(tempMinimal-boxVal)<0.001)):
            box.actualStart = tempPoint
            if(len(box.minimalValue)<1 or boxVal<box.minimalValue[-1]):
                box.minimalValue.append(boxVal)
                box.minimalCoordinate.append(tempPoint)
                box.calls.append(box.totalCalls)
            box.radius *= 2
            print("Raidus is increased to: ",box.radius)
            return True,boxVal
        else:
            box.radius *= 0.75
            print("Raidus is decreased to: ",box.radius)
            return False,boxVal

    def resetAspen():
        from pynput.mouse import Button, Controller
        # Get the mouse controlled
        mouse = Controller()
        # The current coordinate of mouse
        print(mouse.position)
        # Mouse with the new coordinate
        mouse.position = (784, 705)
        # left click
        mouse.click(Button.left, 1)

    '''maximum number of function evaluation is 2200'''
    ''' Connecting to the Aspen Hysys App just one time during optimization'''      
    print(' # Connecting to the Aspen Hysys App ... ')
    hyapp    = win32.Dispatch('HYSYS.Application')			   # Connecting to the Application
    hyCase   = hyapp.ActiveDocument                          # Access to active document
    hysolver = hyCase.Solver

    box = blackBox(name='HYSYS',cycles=cycles)
    box.lowBound=np.array([0.3000,0.7500,1.8750,4.6750,0.8590,2.5970,2.5410,3.9110])
    box.upBound=np.array([5.7000,14.2500,35.6250,88.8250,16.3210,49.3430,48.2790,74.3090])
    box.iniStart = (box.lowBound+box.upBound)/3
    box.genActualStart("origin")
    box.numOfVar = 8

    # Initialization
    box.samples = 12
    box.radius = 3

    for cycle in range(box.cycles):
        print("The No.",cycle+1,"Cycle")

        for indexOfVar in range(box.numOfVar):
            print("The No.",indexOfVar+1,"Variable")

            sampleFlag = False
            sampleCount = 0
            while(sampleFlag is not True):
                sampleCount +=1 
                print("loop of sampling:",sampleCount)
                lb,ub = box.genVariableBoundOld(indexOfVar)
                tempXdata = box.genSamplePoints("vander",box.samples,lb,ub)
                # evalute sampling points
                tempydata = genHYSYSValuesSeq(box.actualStart,tempXdata,indexOfVar,hyCase,hysolver)
                # remove those unavailable data points
                print("Temp X data:",tempXdata)
                print("Temp y data:",tempydata)   
                Xdata = []
                ydata = []
                for i in range(len(tempydata)):
                    if(tempydata[i] < 1e3):
                        Xdata.append(tempXdata[i])
                        ydata.append(tempydata[i])
                if(len(Xdata)>2 and len(ydata)>2):
                    break
                elif(sampleCount > 3):
                    break
                elif(len(Xdata)==0 and len(ydata)==0):
                    sampleFlag = True
                    break
                else:
                    box.samples += 4
                    if(box.samples >= 30):
                        box.radius *= 2
                        print("Raidus is increased to: ",box.radius)
                        box.samples = int(box.samples/2)

            if(sampleCount>3 or sampleFlag == True):
                print("Sampling counter is too big, get to the next loop")
                print("current coordinate:",box.actualStart)
                box.radius *= 2
                continue

            print("X data:",Xdata)
            print("y data:",ydata)            

            labels, expr = callAlamopy(Xdata, ydata, lb, ub)
            tempPoint, tempMinimal = box.callBaron(labels,expr, lb, ub, indexOfVar)

            flag, boxVal = updateHYSYSflag(box,tempPoint,tempMinimal,indexOfVar,hyCase,hysolver)
            
            print("current coordinate:",box.actualStart)
            print("available:",box.minimalValue)
            print("Flag: ", flag)
            if(flag == False):
                box.samples += 4
            else:
                if(box.samples > 6):
                    box.samples = int(box.samples/2)
                else:
                    box.samples = 3
                # Store all of the output and coordinates for future inspection
                box.allCalls.append(box.totalCalls)
                box.allValue.append(boxVal)
            if(box.checkEnd() == True or box.totalCalls>5000):
                print("Exit normally:",box.calls[-1])
                print("Recording calls:",box.allCalls)
                print("Recording points:",box.allValue)
                return
            # resetAspen()

    # f_x0 = hy_Object(hyCase, hysolver, box.iniStart)
    # print('function output of x0 is: ',f_x0)
    return
"""
================================================================================
main function
================================================================================
"""
if __name__ == "__main__":
    fileName = sys.argv[1]
    cycles = int(sys.argv[2])

def main():
    if fileName != 'HYSYS':
        import time
        box = blackBox(name=fileName,cycles=cycles)
        box.compileCode()
        box.readDataFile()
        box.genBackupStart()
        box.genActualStart("origin")

        startTime = time.time()
        # box.coordinateSearch()
        box.coordinateSearchOld('latin')
        # box.coordinateSearchBeta()
        endTime = time.time()
        dur = endTime - startTime
        # box.showParameter()
        box.getResult()
        box.makeCsv(time=dur)
        box.makePlot(fileName+" latin")
    else:
        HYSYSsimulation(cycles)

main()