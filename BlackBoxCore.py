'''
MS project algorithm
Muyi Song (muyis)
Latest update: 7/25/2019

command line syntax: python BlackBox.py (name of model file) (number of iterations)
                                            sys.argv[1]             sys.argv[2]
sampling methods:
1. Hammersley sequence
2. Ver der Corput sequence
3. Halton sequence
4. Latin Random

search algorithm:
1. Coordinate search (shuffle the order of variables every iteration)
=================================================================================
'''
import os
import sys
from pyomo.environ import *
from pyomo.opt import SolverFactory

"""
================================================================================
support functions
================================================================================
"""
def writeInput(filename,input_values):
    infile = open(filename, 'w')
    for val in input_values:
        infile.write(str(val)+'\n')
    infile.close()

def readOutput(filename):
    readfile = open(filename, 'r')
    line = readfile.readline()
    if(line.strip() == "1.#INF00000000000"):
        return "INF"
    else:
        output_value = float(line.strip())
        return output_value
    
def genBlackBoxValue(filename,input_values):
    input_filename = "input.in"
    output_filename = "output.out"
    
    writeInput(input_filename,input_values)
    os.system('.\\'+filename)
    output_value = readOutput(output_filename)
    return output_value

def genBlackBoxValuesSeq(filename,point,sequence,index):
    input_filename = "input.in"
    output_filename = "output.out"
    output_values = []
    for val in sequence:
        input_copy = point[:]
        input_copy[index] = val
        writeInput(input_filename,input_copy)
        os.system('.\\'+filename)
        output_values.append(readOutput(output_filename))
    return output_values

'''
Regression, use alamopy package to get the numerical expression
:param list input_values: values of variables
:param list output_values: values generated by black box models
:paran real lowerBound: lower boundary of specific variable
:param real upperBound: upper boundary of specific variable
:ruturn: labels of variables and expression of the function
'''
def callAlamopy(input_values,output_values,lowerBound,upperBound):
    import alamopy
    alamo_result = alamopy.alamo(xdata=input_values,zdata=output_values,xmin=lowerBound,xmax=upperBound,monomialpower=(1,2),multi2power=(1,2))
#     print("===============================================================")
#     print("ALAMO results")
#     print("===============================================================")
#     print("#Model expression: ",alamo_result['model'])
#     print("#Rhe sum of squared residuals: ",alamo_result['ssr'])
#     print("#R squared: ",alamo_result['R2'])
#     print("#Root Mean Square Error: ",alamo_result['rmse'])
#     print("---------------------------------------------------------------")
    labels = alamo_result['xlabels']
    expr = alamo_result['f(model)']
    return labels,expr

"""
================================================================================
definition of the core class
================================================================================
"""
class blackBox(object):
    radius = 0.5
    def __init__(self,name=None,cycles=None,radius=None,
                 numOfVar=None,
                 lowBound=[],upBound=[],
                 iniStart=[],backUpStart=[],actualStart=[]):
        self.name = name
        self.cycles = cycles
        self.radius = radius
        self.numOfVar = numOfVar
        self.lowBound = lowBound
        self.upBound = upBound
        self.iniStart = iniStart
        self.backUpStart = backUpStart
        self.actualStart = actualStart

    def clear(self):
        self.name=None
        self.cycles=None
        self.radius=None
        self.numOfVar = None
        self.lowBound = []
        self.upBound = []
        self.iniStart = []
        self.backUpStart = []
        self.actualStart = []
    
    def showParameter(self):
        print("Name:",self.name)
        print("Total number of cycles:",self.cycles)
        print("Search radius:",self.radius)
        print("Number of variables:",self.numOfVar)
        print("lowBound:",self.lowBound)
        print("upBound:",self.upBound)
        print("Initial starting point from data file:",self.iniStart)
        print("Back up starting points:",self.backUpStart)
        print("Actual starting point is:",self.actualStart)
        
    '''
    Compile .c file
    :param string filename: name of c file (with out extension)
    ''' 
    def compileCode(self):
        os.system('gcc source_princetonlibgloballib/'+self.name+'.c -lm -o '+self.name)
        after_name = self.name+".exe"
        print("Blackbox Model Name: ",self.name)
        if(os.path.exists(after_name)):
            print("Compilation finished")
        else:
            print("Compilation failed")
    
    
    '''
    Read boundaries, starting points and number of variables
    :param string filename: name of c file (with out extension)
    '''
    def readDataFile(self):
        infile = open("problemdata/"+self.name+".problem.data",'r')
        lines = infile.readlines()
        # The first line
        for num in lines[0].split():
            self.numOfVar = int(num.strip())
        # The second line
        for i in lines[1].split():
            self.lowBound.append(float(i.strip()))
        # The third line
        for j in lines[2].split():
            self.upBound.append(float(j.strip()))
        # The fourth line
        for k in lines[3].split():
            self.iniStart.append(float(k.strip()))
        infile.close()
    '''
    Generate starting points that are ready to be chose
    '''
    def genBackupStart(self):
        import numpy as np    
        # TODO: Finally I want to generate 10 backup starting points, which can be modifed later
        for i in range(len(self.lowBound)):
            arr = np.linspace(self.lowBound[i],self.upBound[0],12)
            self.backUpStart.append(arr)
        self.backUpStart = np.transpose(self.backUpStart)[1:-1]
    
    '''
    Choose a starting point from backup and check if it is valid,
    otherwise remove that point from list and choose another one
    '''
    def genActualStart(self):
        import random
        self.actualStart = random.choice(self.backUpStart)
        output = genBlackBoxValue(self.name,self.actualStart)
        while(output == "INF"):
            self.backUpStart.remove(self.actualStart)
            self.actualStart = random.choice(self.backUpStart)
            output = genBlackBoxValue(self.name,self.actualStart)

    def genVariableBound(self,index):
        if(self.actualStart[index]-self.radius<self.lowBound[index]):
            lb = self.lowBound[index]
        else:
            lb = self.actualStart[index]-self.radius
        
        if(self.actualStart[index]+self.radius>self.upBound[index]):
            ub = self.upBound[index]
        else:
            ub = self.actualStart[index]+self.radius
        return lb,ub
    

    def call_baron(labels,expr,lowerBound,upperBound,startPoint,index):

        model = ConcreteModel(name='cycle')
        lBound_dic,uBound_dic = boundary_dic(labels,startPoint,index,lowerBound,upperBound)
        def fb(model,i):
            return (lBound_dic[i],uBound_dic[i])
        model.A = Set(initialize=labels)
        model.x = Var(model.A,within=Reals,bounds=fb)
        
        def objrule(model):
            var_lst = []
            for var_name in model.x:
                var_lst.append(model.x[var_name])
            return expr(var_lst)
        model.obj = Objective(rule=objrule,sense=minimize)
        opt = SolverFactory('baron')
        solution = opt.solve(model)
    #     solution.write()
    #     model.pprint()
    #     model.display()
        
        obj_point = startPoint
        try:
            obj_point[index] = value(model.x[labels[0]])
            # print(value(model.x[labels[index]]))
        except:
            obj_point = startPoint
        obj_value = value(model.obj)
        return obj_point,obj_value
    
    def coordinateSearch(self):
        import random
        from Sampling import halton_sequence,hammersley_sequence,van_der_corput,latin_random_sequence
        for cycle in range(self.cycles):
            print("The No.",cycle+1,"Cycle")
            shuffleOrder = list(range(self.numOfVar))
            random.shuffle(shuffleOrder)
            for indexOfVar in shuffleOrder:
                lb,ub = self.genVariableBound(indexOfVar)
                print(indexOfVar,shuffleOrder)
                Xdata,_ = van_der_corput(lb,ub,20,2)
                ydata = genBlackBoxValuesSeq(self.name,self.actualStart,Xdata,indexOfVar)
                print(ydata)
                labels,expr = callAlamopy(Xdata,ydata,lb,ub)
                print(labels,expr)

"""
================================================================================
main function
================================================================================
"""
if __name__ == "__main__":
    fileName = sys.argv[1]
    cycles = int(sys.argv[2])

def main():
    import time
    box = blackBox(name=fileName,cycles=cycles,radius=1.0)
    box.compileCode()
    box.readDataFile()
    box.genBackupStart()
    box.genActualStart()
    box.coordinateSearch()
    box.showParameter()       

main()